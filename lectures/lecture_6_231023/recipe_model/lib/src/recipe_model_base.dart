// immutable data, from/toJson, copyWith functions for easily yielding new copies
import 'dart:convert';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:hive/hive.dart';

// required: associates our `recipe_model_base.dart` with the code generated by Freezed
part 'recipe_model_base.freezed.dart';

// optional: Since our Exercise/recipeSession class is serializable, we must add this line.
part 'recipe_model_base.g.dart';

// required: our model code implements the provided interfaces
part 'recipe_model_interfaces.dart';

@freezed
abstract class Ingredient with _$Ingredient implements IIngredient {
  @Implements<IIngredient>()
  const factory Ingredient({
    required String id,
    required String name,
    required String description,
    int? defaultAmount,
    MeasurementUnit? defaultUnit,
  }) = _Ingredient;

  factory Ingredient.fromJson(Map<String, dynamic> json) =>
      _$IngredientFromJson(json);
}

@freezed
abstract class RecipeStep with _$RecipeStep implements IRecipeStep {
  @Implements<IRecipeStep>()
  const factory RecipeStep({
    required Ingredient ingredient,
    required MeasurementUnit unit,
    required int amount,
  }) = _RecipeStep;

  factory RecipeStep.fromJson(Map<String, dynamic> json) =>
      _$RecipeStepFromJson(json);
}

@freezed
abstract class Recipe with _$Recipe implements IRecipe {
  @Implements<IRecipe>()
  const factory Recipe({
    required String name,
    required String id,
    required List<String> instructions,
    required List<RecipeStep> steps,
  }) = _Recipe;

  factory Recipe.fromJson(Map<String, dynamic> json) => _$RecipeFromJson(json);
}

void main(List<String> args) {
  Recipe recipe = Recipe(name: "name", id: "id", instructions: [], steps: []);
  recipe.instructions.add("yo");
}

abstract class HiveRepository<T extends Identifiable>
    implements IRepository<T> {
  abstract String _collectionName;
  late Box<String> box;

  Future<void> initialize({required String filePath}) async {
    Hive.init('$filePath/hive');
    box = await Hive.openBox<String>(_collectionName);
  }

  Future<void> initializeWeb() async {
    box = await Hive.openBox<String>(_collectionName);
  }

  Future<ActionResult<void>> destroy() async {
    try {
      await box.clear();
      await Hive.deleteBoxFromDisk(_collectionName);
      await Hive.deleteBoxFromDisk(_collectionName);

      return ActionResult.success();
    } catch (e) {
      return ActionResult.failure(ActionStatus.DatabaseError, e);
    }
  }

  @override
  Future<ActionResult<T>> create(T item) async {
    try {
      if (box.containsKey(item.id)) {
        return ActionResult.failure(ActionStatus.ValidationFailed);
      }
      await box.put(item.id, serialize(item));

      return ActionResult.success(item);
    } catch (e) {
      return ActionResult.failure(ActionStatus.DatabaseError, e);
    }
  }

  @override
  Future<ActionResult<void>> delete(String id) async {
    try {
      if (!box.containsKey(id)) {
        return ActionResult.failure(ActionStatus.NotFound);
      }
      await box.delete(id);
      return ActionResult.success();
    } catch (e) {
      return ActionResult.failure(ActionStatus.DatabaseError, e);
    }
  }

  @override
  FResult<T> read(String id) async {
    try {
      final item = box.get(id);
      if (item == null) {
        return ActionResult.failure(ActionStatus.NotFound);
      }
      return ActionResult.success(deserialize(item));
    } catch (e) {
      return ActionResult.failure(ActionStatus.DatabaseError, e);
    }
  }

  @override
  FResult<List<T>> list() async {
    try {
      final items = box.values.map((item) => deserialize(item)).toList();
      return ActionResult.success(items);
    } catch (e) {
      return ActionResult.failure(ActionStatus.DatabaseError, e);
    }
  }

    @override
  FResult<List<T>> list_two() async {
    try {
      final items = box.values.map((item) => deserialize(item)).toList();
      return ActionResult.success(items);
    } catch (e) {
      return ActionResult.failure(ActionStatus.DatabaseError, e);
    }
  }

  @override
  Future<ActionResult<T>> update(String id, T item) async {
    try {
      if (!box.containsKey(id)) {
        return ActionResult.failure(ActionStatus.NotFound);
      }
      await box.put(id, serialize(item));
      return ActionResult.success(item);
    } catch (e) {
      return ActionResult.failure(ActionStatus.DatabaseError, e);
    }
  }

  @override
  Future<ActionResult<void>> clear() async {
    try {
      await box.clear();
      await box.close();
      return ActionResult.success();
    } catch (e) {
      return ActionResult.failure(ActionStatus.DatabaseError, e);
    }
  }
}

class IngredientRepository extends HiveRepository<Ingredient> {
  @override
  String _collectionName = "ingredients";

  // Private constructor
  IngredientRepository._();

  // Singleton instance
  static final IngredientRepository _instance = IngredientRepository._();

  // Public getter to access the singleton instance
  static IngredientRepository get instance {
    return _instance;
  }

  @override
  Ingredient Function(String item) get deserialize =>
      (item) => Ingredient.fromJson(json.decode(item));

  @override
  String Function(Ingredient item) get serialize =>
      (item) => json.encode(item.toJson());
}

class RecipeRepository extends HiveRepository<Recipe> {
  @override
  String _collectionName = "recipes";

  // Private constructor
  RecipeRepository._();

  // Singleton instance
  static final RecipeRepository _instance = RecipeRepository._();

  // Public getter to access the singleton instance
  static RecipeRepository get instance {
    return _instance;
  }

  @override
  Recipe Function(String item) get deserialize =>
      (item) => Recipe.fromJson(json.decode(item));

  @override
  String Function(Recipe item) get serialize =>
      (item) => json.encode(item.toJson());
}
